using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Drawing;


namespace _belinda
{
    public class Belinda : NQuotes.MqlApi
    {
        //+------------------------------------------------------------------+
        //| This MQL is generated by Expert Advisor Builder                  |
        //|                http://sufx.core.t3-ism.net/ExpertAdvisorBuilder/ |
        //|                                                                  |
        //|  In no event will author be liable for any damages whatsoever.   |
        //|                      Use at your own risk.                       |
        //|                                                                  |
        //|   Modified by Lucas Liew                                         |                                                                 
        //|                                                                  |
        //+------------------- DO NOT REMOVE THIS HEADER --------------------+

        /* 
           BELINDA ENTRY RULES:
           If Current Volatility (ATR(20)) is greater than Volatility (ATR(20)) 10 hours ago:
           Enter a long trade when SMA(10) crosses SMA(40) from bottom
           Enter a short trade when SMA(10) crosses SMA(40) from top

           BELINDA EXIT RULES:
           Exit the long trade when SMA(10) crosses SMA(40) from top
           Exit the short trade when SMA(10) crosses SMA(40) from bottom
           30 pips hard stop (30pips from initial entry price)
           Trailing stop of 30 pips

           BELINDA POSITION SIZING RULE:
           Sizing based on account size
        */
        const int SIGNAL_NONE = 0;
        const int SIGNAL_BUY = 1;
        const int SIGNAL_SELL = 2;
        const int SIGNAL_CLOSEBUY = 3;
        const int SIGNAL_CLOSESELL = 4;


        public int MagicNumber = 12345;
        public bool SignalMail = false;
        public double Lots = 1.0;
        public int Slippage = 3;
        public bool UseStopLoss = true;
        public int StopLoss = 30;
        public bool UseTakeProfit = false;
        public int TakeProfit = 0;
        public bool UseTrailingStop = true;
        public int TrailingStop = 30;

        public int sma_short = 10;
        public int sma_long = 40;
        public int atr_period = 20;
        public int atr_shift = 11;

        public bool isSizingOn = true;
        public double Risk = 1;

        int P = 1;
        int Order = SIGNAL_NONE;
        int Total, Ticket, Ticket2;
        bool _Total, _Ticket, _Ticket2;
        double StopLossLevel, TakeProfitLevel, StopLevel;
        double sma10_1, sma10_2, sma40_1, sma40_2;
        double atr_current, atr_past;
        bool isYenPair = false;



        //TDL 1: Declare variables needed for Cross function (see Function Notes below)

        //+------------------------------------------------------------------+
        //| Expert initialization function                                   |
        //+------------------------------------------------------------------+
        public override int init()
        {

            if (Digits == 5 || Digits == 3 || Digits == 1) P = 10; else P = 1; // To account for 5 digit brokers
            if (Digits == 3 || Digits == 2) isYenPair = true; // Adjust for YenPair

            return (0);
        }
        //+------------------------------------------------------------------+
        //| Expert initialization function - END                             |
        //+------------------------------------------------------------------+
        //+------------------------------------------------------------------+
        //| Expert deinitialization function                                 |
        //+------------------------------------------------------------------+
        public override int deinit()
        {
            return (0);
        }
        //+------------------------------------------------------------------+
        //| Expert deinitialization function - END                           |
        //+------------------------------------------------------------------+
        //+------------------------------------------------------------------+
        //| Expert start function                                            |
        //+------------------------------------------------------------------+
        public override int start()
        {

            Total = OrdersTotal();
            Order = SIGNAL_NONE;

            //+------------------------------------------------------------------+
            //| Variable Setup                                                   |
            //+------------------------------------------------------------------+

            sma10_1 = iMA(null, 0, sma_short, 0, MODE_SMA, PRICE_CLOSE, 1); // c
            sma10_2 = iMA(null, 0, sma_short, 0, MODE_SMA, PRICE_CLOSE, 2); // b
            sma40_1 = iMA(null, 0, sma_long, 0, MODE_SMA, PRICE_CLOSE, 1); // d
            sma40_2 = iMA(null, 0, sma_long, 0, MODE_SMA, PRICE_CLOSE, 2); // a

            atr_current = iATR(null, 0, atr_period, 1);    // ATR(20) now
            atr_past = iATR(null, 0, atr_period, atr_shift);      // ATR(20) 10 periods ago

            StopLevel = (MarketInfo(Symbol(), MODE_STOPLEVEL) + MarketInfo(Symbol(), MODE_SPREAD)) / P; // Defining minimum StopLevel

            if (StopLoss < StopLevel) StopLoss = (int)StopLevel;
            if (TakeProfit < StopLevel) TakeProfit = (int)StopLevel;

            if (isSizingOn == true)
            {
                Lots = Risk * 0.01 * AccountBalance() / (MarketInfo(Symbol(), MODE_LOTSIZE) * StopLoss * P * Point); // Sizing Algo based on account size
                if (isYenPair == true) Lots = Lots * 100; // Adjust for Yen Pairs
                Lots = NormalizeDouble(Lots, 2); // Round to 2 decimal place
            }
            //+------------------------------------------------------------------+
            //| Variable Setup - END                                             |
            //+------------------------------------------------------------------+

            //Check position
            bool IsTrade = false;

            for (int i = 0; i < Total; i++)
            {
                _Ticket2 = OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
                if (OrderType() <= OP_SELL && OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
                {
                    IsTrade = true;
                    if (OrderType() == OP_BUY)
                    {
                        //Close

                        //+------------------------------------------------------------------+
                        //| Signal Begin(Exit Buy)                                           |
                        //+------------------------------------------------------------------+

                        /* BELINDA EXIT RULES:
                           Exit the long trade when SMA(10) crosses SMA(40) from top
                           Exit the short trade when SMA(10) crosses SMA(40) from bottom
                           30 pips hard stop (30pips from initial entry price)
                           Trailing stop of 30 pips
                        */

                        // TDL 3: Replace exit rules with cross function

                        if (sma10_2 > sma40_2 && sma40_1 >= sma10_1) Order = SIGNAL_CLOSEBUY; // Rule to EXIT a Long trade

                        //+------------------------------------------------------------------+
                        //| Signal End(Exit Buy)                                             |
                        //+------------------------------------------------------------------+

                        if (Order == SIGNAL_CLOSEBUY)
                        {
                            _Ticket2 = OrderClose(OrderTicket(), OrderLots(), Bid, Slippage, Color.MediumSeaGreen);
                            if (SignalMail) SendMail("[Signal Alert]", "[" + Symbol() + "] " + DoubleToStr(Bid, Digits) + " Close Buy");
                            IsTrade = false;
                            continue;
                        }
                        //Trailing stop
                        if (UseTrailingStop && TrailingStop > 0)
                        {
                            if (Bid - OrderOpenPrice() > P * Point * TrailingStop)
                            {
                                if (OrderStopLoss() < Bid - P * Point * TrailingStop)
                                {
                                    _Ticket2 = OrderModify(OrderTicket(), OrderOpenPrice(), Bid - P * Point * TrailingStop, OrderTakeProfit(), DateTime.MinValue, Color.MediumSeaGreen);
                                    continue;
                                }
                            }
                        }
                    }
                    else
                    {
                        //Close

                        //+------------------------------------------------------------------+
                        //| Signal Begin(Exit Sell)                                          |
                        //+------------------------------------------------------------------+

                        if (sma40_2 > sma10_2 && sma10_1 >= sma40_1) Order = SIGNAL_CLOSESELL; // Rule to EXIT a Short trade

                        //+------------------------------------------------------------------+
                        //| Signal End(Exit Sell)                                            |
                        //+------------------------------------------------------------------+

                        if (Order == SIGNAL_CLOSESELL)
                        {
                            _Ticket2 = OrderClose(OrderTicket(), OrderLots(), Ask, Slippage, Color.DarkOrange);
                            if (SignalMail) SendMail("[Signal Alert]", "[" + Symbol() + "] " + DoubleToStr(Ask, Digits) + " Close Sell");
                            continue;
                        }
                        //Trailing stop
                        if (UseTrailingStop && TrailingStop > 0)
                        {
                            if ((OrderOpenPrice() - Ask) > (P * Point * TrailingStop))
                            {
                                if ((OrderStopLoss() > (Ask + P * Point * TrailingStop)) || (OrderStopLoss() == 0))
                                {
                                    _Ticket2 = OrderModify(OrderTicket(), OrderOpenPrice(), Ask + P * Point * TrailingStop, OrderTakeProfit(), DateTime.MinValue, Color.DarkOrange);
                                    continue;
                                }
                            }
                        }
                    }
                }
            }

            //+------------------------------------------------------------------+
            //| Signal Begin(Entries)                                            |
            //+------------------------------------------------------------------+

            /* BELINDA ENTRY RULES:
               If Current Volatility (ATR(20)) is greater than Volatility (ATR(20)) 10 hours ago:
               Enter a long trade when SMA(10) crosses SMA(40) from bottom
               Enter a short trade when SMA(10) crosses SMA(40) from top
            */

            // TDL 2: Replace entry rules with cross function

            if (atr_current > atr_past)
            {

                if (sma40_2 > sma10_2 && sma10_1 >= sma40_1) Order = SIGNAL_BUY; // Rule to ENTER a Long trade

                if (sma10_2 > sma40_2 && sma40_1 >= sma10_1) Order = SIGNAL_SELL; // Rule to ENTER a Short trade

            }

            //+------------------------------------------------------------------+
            //| Signal End                                                       |
            //+------------------------------------------------------------------+

            //Buy
            if (Order == SIGNAL_BUY)
            {
                if (!IsTrade)
                {
                    //Check free margin
                    if (AccountFreeMargin() < (1000 * Lots))
                    {
                        Print("We have no money. Free Margin = ", AccountFreeMargin());
                        return (0);
                    }

                    if (UseStopLoss) StopLossLevel = Ask - StopLoss * Point * P; else StopLossLevel = 0.0;
                    if (UseTakeProfit) TakeProfitLevel = Ask + TakeProfit * Point * P; else TakeProfitLevel = 0.0;

                    Ticket = OrderSend(Symbol(), OP_BUY, Lots, Ask, Slippage, StopLossLevel, TakeProfitLevel, "Buy(#" + MagicNumber + ")", MagicNumber, DateTime.MinValue, Color.DodgerBlue);
                    if (Ticket > 0)
                    {
                        if (OrderSelect(Ticket, SELECT_BY_TICKET, MODE_TRADES))
                        {
                            Print("BUY order opened : ", OrderOpenPrice());
                            if (SignalMail) SendMail("[Signal Alert]", "[" + Symbol() + "] " + DoubleToStr(Ask, Digits) + " Open Buy");
                        }
                        else
                        {
                            Print("Error opening BUY order : ", GetLastError());
                        }
                    }
                    return (0);
                }
            }
            
            //Sell
            if (Order == SIGNAL_SELL)
            {
                if (!IsTrade)
                {
                    //Check free margin
                    if (AccountFreeMargin() < (1000 * Lots))
                    {
                        noMoneyPrint();
                        return (0);
                    }

                    if (UseStopLoss) StopLossLevel = Bid + StopLoss * Point * P; else StopLossLevel = 0.0;
                    if (UseTakeProfit) TakeProfitLevel = Bid - TakeProfit * Point * P; else TakeProfitLevel = 0.0;

                    Ticket = OrderSend(Symbol(), OP_SELL, Lots, Bid, Slippage, StopLossLevel, TakeProfitLevel, "Sell(#" + MagicNumber + ")", MagicNumber, DateTime.MinValue, Color.DeepPink);
                    if (Ticket > 0)
                    {
                        if (OrderSelect(Ticket, SELECT_BY_TICKET, MODE_TRADES))
                        {
                            Print("SELL order opened : ", OrderOpenPrice());
                            if (SignalMail) SendMail("[Signal Alert]", "[" + Symbol() + "] " + DoubleToStr(Bid, Digits) + " Open Sell");
                        }
                        else
                        {
                            Print("Error opening SELL order : ", GetLastError());
                        }
                    }
                    return (0);
                }
            }

            return (0);
        }
        //+------------------------------------------------------------------+

        //+------------------------------------------------------------------+
        // FUNCTION LIBRARY                                                  |
        //+------------------------------------------------------------------+

        //+------------------------------------------------------------------+
        // Customized Print                                                  |
        //+------------------------------------------------------------------+
        void noMoneyPrint()
        {

            Print("We have no money. Free Margin = ", AccountFreeMargin());

        }
        //+------------------------------------------------------------------+
        // End of Customized Print                                           |
        //+------------------------------------------------------------------+

        //+------------------------------------------------------------------+
        // Cross                                                             |
        //+------------------------------------------------------------------+

        /* 

        Function Notes:

        Declare these before the init() of the EA 

        int current_direction, last_direction;
        bool first_time = True;

        ----  

        If Output is 0: No cross happened
        If Output is 1: Line 1 crossed Line 2 from Bottom
        If Output is 2: Line 1 crossed Line 2 from top 

        */

        /*int Crossed(double line1, double line2)
        {

            //----
            if (line1 > line2)
                current_direction = 1;  // line1 above line2
            if (line1 < line2)
                current_direction = 2;  // line1 below line2
                                        //----
            if (first_time == true) // Need to check if this is the first time the function is run
            {
                first_time = false; // Change variable to false
                last_direction = current_direction; // Set new direction
                return (0);
            }

            if (current_direction != last_direction && first_time == false)  // If not the first time and there is a direction change
            {
                last_direction = current_direction; // Set new direction
                return (last_direction); // 1 for up, 2 for down
            }
            else
            {
                return (0);  // No direction change
            }
        }

        /* For Cross Function, declare these before the init() of the EA 

        int current_direction, last_direction;
        bool first_time;

        */

        //+------------------------------------------------------------------+
        // End of Cross                                                      |
        //+------------------------------------------------------------------+


    }
}
